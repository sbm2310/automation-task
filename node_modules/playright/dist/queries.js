"use strict";
// MIT License
//
// Copyright (c) 2020 Iakiv Kramarenko, Alexander Popov
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", { value: true });
exports.query = void 0;
/**
 * TODO: should we make the structure like query.element.text?
 * TODO: should we make it's possible to compose queries by the user
 *       something like
 *           query = {...query.element, ...query.browser, ...query.elements}
 */
var query;
(function (query) {
    /**
     * there are actually innerText and textContent
     * fully described here: https://stackoverflow.com/a/35213639/1297371
     * in short, the innerText = visible text
     *
     * TODO: how should we name the thing below? what about textContent too?
     */
    /**
     * TODO: refactor queries from callable objects to classic functions with
     *       overriden toString method like in selenidejs
     *       use named from ./utils/fp
     */
    query.text = {
        toString: () => 'text',
        call: element => element.handle().then(its => its.innerText()),
    };
    function attribute(name) {
        return {
            toString: () => `attribute ${name}`,
            call: element => element.handle().then(its => its.getAttribute(name)),
        };
    }
    query.attribute = attribute;
    query.outerHtml = attribute('outerHTML');
    /* --- elements collection queries --- */
    query.count = {
        toString: () => 'count',
        call: elements => elements.handles().then(their => their.length),
    };
    // TODO: do we need this alias?
    query.length = query.count;
    query.texts = {
        toString: () => 'texts',
        call: async (elements) => {
            const innerTexts = [];
            const handles = await elements.handles();
            // eslint-disable-next-line no-restricted-syntax
            for (const handle of handles) {
                innerTexts.push(await handle.innerText());
            }
            return innerTexts;
        },
    };
})(query = exports.query || (exports.query = {}));
