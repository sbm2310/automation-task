"use strict";
/* eslint-disable no-shadow */
// MIT License
//
// Copyright (c) 2020 Iakiv Kramarenko, Alexander Popov
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", { value: true });
exports.be = exports.have = exports.match = void 0;
const callables_1 = require("./callables");
const queries_1 = require("./queries");
const utils_1 = require("./utils");
// TODO: do we need this match namespace?
var match;
(function (match) {
    /* --- element conditions --- */
    // TODO: do we need a nested namespace? like match.element.isVisible ?
    match.visible = callables_1.Condition.failIfNot('is visible', async (element) => {
        const handle = await element.handle();
        const box = await handle.boundingBox();
        return box !== null;
    });
    match.text = (expected) => callables_1.Condition.failIfNotActual(`has text: ${expected}`, queries_1.query.text, typeof expected === 'string' ? utils_1.predicate.includes(expected) : utils_1.predicate.matches(expected));
    match.exactText = (expected) => callables_1.Condition.failIfNotActual(`has exact text: ${expected}`, queries_1.query.text, typeof expected === 'string' ? utils_1.predicate.equals(expected) : utils_1.predicate.matches(expected));
    match.cssClass = (name) => callables_1.Condition.failIfNotActual(`has css class '${name}'`, queries_1.query.attribute('class'), utils_1.predicate.includesWord(name));
    const attributeWithValue = (name, value) => new callables_1.Condition(`has attribute: ${name}=${value}`, async (element) => {
        const attr = await queries_1.query.attribute(name).call(element);
        if (typeof value === 'string') {
            if (value === attr) {
                return;
            }
        }
        else if (value.test(attr)) {
            return;
        }
        throw new Error(`actual ${name}="${attr}"`);
    });
    const attributeWithoutValue = (name) => new callables_1.Condition(`has attribute: ${name}`, async (element) => {
        const attr = await queries_1.query.attribute(name).call(element);
        if (attr === null) {
            throw new Error('actual: absent');
        }
    });
    match.attribute = (name, value) => {
        if (value !== undefined) {
            return attributeWithValue(name, value);
        }
        return attributeWithoutValue(name);
    };
    match.element = (locator) => callables_1.Condition.failIfNot(`has element "${locator}"`, async (element) => element
        .$(locator)
        .handle()
        .then(it => it !== null));
    /* --- elements collection conditions --- */
    // throwing 'cannot read includes of undefined randomly'
    // export const texts = (...values: string[] | number[]) => Condition.failIfNotActual(`have texts ${values}`, query.texts, predicate.equalsByContainsToArray(values));
    match.texts = (...values) => new callables_1.Condition(`have texts ${values}`, async (elements) => {
        const actualTexts = await queries_1.query.texts.call(elements);
        if (actualTexts.length !== values.length) {
            throw new Error(`actual ${actualTexts}`);
        }
        for (let i = 0; i < actualTexts.length; i += 1) {
            const actual = actualTexts[i].trim() || '';
            const expected = String(values[i]).trim();
            if (!actual.includes(expected)) {
                throw new Error(`actual ${actualTexts}`);
            }
        }
    });
    match.count = (num) => callables_1.Condition.failIfNotActual(`have size ${num}`, queries_1.query.count, utils_1.predicate.equals(num));
})(match = exports.match || (exports.match = {}));
var have;
(function (have) {
    have.text = match.text;
    have.exactText = match.exactText;
    have.cssClass = match.cssClass;
    have.texts = match.texts;
    have.count = match.count;
    have.attribute = match.attribute;
    have.element = match.element;
    let no;
    (function (no) {
        no.text = (expected) => match.text(expected).not;
        no.cssClass = (name) => match.cssClass(name).not;
        no.texts = (...values) => match.texts(...values).not;
        no.count = (num) => match.count(num).not;
        no.attribute = (name, value) => match.attribute(name, value).not;
    })(no = have.no || (have.no = {}));
})(have = exports.have || (exports.have = {}));
var be;
(function (be) {
    be.visible = match.visible;
    let not;
    (function (not) {
        not.visible = match.visible.not;
    })(not = be.not || (be.not = {}));
})(be = exports.be || (exports.be = {}));
