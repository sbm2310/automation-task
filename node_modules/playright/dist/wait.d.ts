import { TimeoutError } from './errors';
import { Callable } from './callables';
export declare class Wait<T> {
    private readonly entity;
    private readonly timeout;
    private readonly pollingInterval;
    readonly handleFailure: (error: TimeoutError) => Promise<Error>;
    constructor(entity: T, timeout: number, pollingInterval?: number, orFailWith?: (error: TimeoutError) => Promise<Error>);
    atMost(timeout: number): Wait<T>;
    orFailWith(handler: (error: TimeoutError) => Promise<Error>): Wait<T>;
    /**
     * TODO: allow accepting as callable a simple fn,
     *       potentially hacked by utils named
     *       same way like queries
     * @param callable
     */
    for<R>(callable: Callable<T, R>): Promise<R>;
    until<R>(callable: Callable<T, R>): Promise<boolean>;
}
//# sourceMappingURL=wait.d.ts.map