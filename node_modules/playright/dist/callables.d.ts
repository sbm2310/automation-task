/**
 * One-argument-async-function
 */
export declare type Lambda<T, R> = (entity: T) => Promise<R>;
/**
 * As-An-Object alternative to Lambda<T, R>
 */
export interface Callable<T, R> {
    call(entity: T): Promise<R>;
    toString?: () => string;
}
export interface Locator<R> {
    call: () => Promise<R>;
    toString?: () => string;
}
/**
 * Callable<T, R> alias...
 * For void version - see Command...
 * Assumes also that error can be thrown
 */
export declare type Query<T, R> = Callable<T, R>;
/**
 * Void version of Query
 * Can throw error on failure
 */
export declare type Command<T> = Query<T, void>;
/**
 * Like Command<T>, that can pass or fail with Error,
 * Named as Condition to reflect scenarios of "predicate-like" usage
 * Condition is like classic Matcher,
 * like Predicate but gives (passed | throws Error) instead of (true | false)
 * or in other words (matched | failed)
 */
export declare class Condition<E> implements Callable<E, void> {
    private readonly description;
    private readonly fn;
    constructor(description: string, fn: Lambda<E, void>);
    call(entity: E): Promise<void>;
    get not(): Condition<E>;
    and(condition: Condition<E>): Condition<E>;
    or(condition: Condition<E>): Condition<E>;
    matches(entity: E): Promise<boolean>;
    predicate(): Callable<E, boolean>;
    toString(): string;
    static failIfNot<E>(description: string, predicate: (entity: E) => Promise<boolean>): Condition<E>;
    static failIfNotActual<E, A>(description: string, query: Callable<E, A>, // TODO: what about accepting simple fn here?
    predicate: (actual: A) => boolean): Condition<E>;
    /**
     * Negates or inverts condition
     */
    static not<T>(condition: Condition<T>, description?: string): Condition<T>;
    /**
     * Combines conditions by logical AND
     */
    static and<T>(...conditions: Condition<T>[]): Condition<T>;
    /**
     * Combines conditions by logical OR
     */
    static or<T>(...conditions: Condition<T>[]): Condition<T>;
    /**
     * Transforms Conditions, i.e. Matchers that return (void | throws Error),
     * combined by AND
     * to async Predicate that returns (true | false)
     */
    static asPredicate<T>(...conditions: Condition<T>[]): (entity: T) => Promise<boolean>;
}
//# sourceMappingURL=callables.d.ts.map